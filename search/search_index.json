{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home Assistant Target Timeframes","text":"<p>Target timeframes was a feature that has been extracted out of the Octopus Energy integration. The idea is you can configure binary sensors that will find and turn on during the most optimal time periods based on external data sources, targeting either the lowest or highest values. What these values represent can be anything. In the original integration, the values represented cost of energy, and so the cheapest periods were discovered. But it could represent other things like </p> <ul> <li>Temperature to turn on sprinklers during the hottest times of the day</li> <li>Carbon emissions to turn on devices when renewables on the grid are at their highest</li> <li>Solar generation to turn on devices when the most energy is being generated.</li> </ul> <p>How the sensors behave is configurable in a number of ways and explained further in the docs.</p>"},{"location":"#how-to-install","title":"How to install","text":"<p>There are multiple ways of installing the integration. Once you've installed the integration, you'll need to setup your account before you can use the integration.</p>"},{"location":"#hacs","title":"HACS","text":"<p>This integration can be installed directly via HACS. To install:</p> <ul> <li>Add the repository to your HACS installation</li> <li>Click <code>Download</code></li> </ul>"},{"location":"#manual","title":"Manual","text":"<p>You should take the latest published release. The current state of <code>develop</code> will be in flux and therefore possibly subject to change.</p> <p>To install, place the contents of <code>custom_components</code> into the <code>&lt;config directory&gt;/custom_components</code> folder of your Home Assistant installation. Once installed, don't forget to restart your home assistant instance for the integration to be picked up.</p>"},{"location":"#how-to-setup","title":"How to setup","text":"<p>You will initially need to setup one or more data sources. You'll then need to setup one or more target timeframe or rolling target timeframe sensors.</p>"},{"location":"#events","title":"Events","text":"<p>This integration raises several events, which can be used for various tasks like automations. For more information, please see the events docs.</p>"},{"location":"#services","title":"Services","text":"<p>This integration includes several services. Please review them in the services doc.</p>"},{"location":"#blueprints","title":"Blueprints","text":"<p>A selection of blueprints are available to help get you up and running quickly with the integration.</p>"},{"location":"#faq","title":"FAQ","text":"<p>Before raising anything, please read through the faq. If you have questions, then you can raise a discussion. If you have found a bug or have a feature request please raise it using the appropriate report template.</p>"},{"location":"#sponsorship","title":"Sponsorship","text":"<p>Please see the sponsorship page for more information.</p>"},{"location":"blueprints/","title":"Blueprints","text":"<p>Blueprints are an excellent way to get you up and running with the integration quickly. They can also be used as a guide for setting up new automations which you can tailor to your needs.</p>"},{"location":"blueprints/#data-sources","title":"Data Sources","text":"<p>The following blueprints can help you configure data sources provided by other integrations</p>"},{"location":"blueprints/#carbon-intensity","title":"Carbon Intensity","text":"<p>Install blueprint | Source</p> <p>This blueprint will provide the data source for the UK Carbon Intensity as provided by the Carbon Intensity integration.</p>"},{"location":"blueprints/#octopus-energy","title":"Octopus Energy","text":"<p>Install blueprint | Source</p> <p>This blueprint will provide the data source for Octopus Energy rates as provided by the Octopus Energy integration.</p>"},{"location":"events/","title":"Events","text":"<p>The following events are raised by the integration. These events power various entities and can also be used within automations.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#ive-updated-the-configuration-of-one-of-my-target-timeframe-sensors-but-its-not-updating-is-there-something-wrong","title":"I've updated the configuration of one of my target timeframe sensors but it's not updating. Is there something wrong?","text":"<p>For some reason when you update the configuration via the integration page, the associated entities don't update. You'll need to reload the parent entry to get the configuration to take effect. This is something I'm currently investigating.</p>"},{"location":"faq/#how-do-i-increase-the-logs-for-the-integration","title":"How do I increase the logs for the integration?","text":"<p>If you are having issues, it would be helpful to include Home Assistant logs as part of any raised issue. This can be done by following the instructions outlined by Home Assistant.</p> <p>You should run these logs for about a day and then include the contents in the issue. Please be sure to remove any personal identifiable information from the logs before including them.</p>"},{"location":"services/","title":"Services","text":"<p>There are a few services available within this integration, which are detailed here.</p>"},{"location":"services/#data-sources","title":"Data Sources","text":""},{"location":"services/#target_timeframesupdate_target_timeframe_data_source","title":"target_timeframes.update_target_timeframe_data_source","text":"<p>Updates the source data for a given targetframe period. This will replace any existing data for the source.</p> <p>There are a collection of blueprints available for loading popular data sources.</p> Attribute Optional Description <code>target.entity_id</code> <code>no</code> The name of the data source last updated sensor whose underlying data is to be updated. <code>data.data</code> <code>no</code> The collection of data to update the data source with. This will override any previous data. For the target rate sensors to work properly, you should target having data for the whole of yesterday, today and tomorrow (e.g. if today is 2025-01-04, you should aim to have data from 2025-01-03T00:00:00 to 2025-01-06T00:00:00). <p>The structure of the data should match the following</p> <pre><code>[\n  {\n    \"start\": \"2025-01-01T00:00:00Z\",\n    \"end\": \"2025-01-01T00:30:00Z\",\n    \"value\": 0.1,\n    \"metadata\": {\n      // Any additional metadata that might describe how the value was created\n    }\n  },\n  {\n    \"start\": \"2025-01-01T00:30:00Z\",\n    \"end\": \"2025-01-01T01:00:00Z\",\n    \"value\": 0.2,\n    \"metadata\": {\n      // Any additional metadata that might describe how the value was created\n    }\n  },\n  ...\n]\n</code></pre> <p>Each item within the data must be in thirty minute increments. The minute must be 00 or 30, the second should be zero.</p>"},{"location":"services/#automations","title":"Automations","text":"<p>Examples can be found in the blueprints section for configuring a variety of different data sources.</p>"},{"location":"services/#target-timeframes","title":"Target Timeframes","text":"<p>The following services are available if you have set up at least one target timeframe.</p>"},{"location":"services/#target_timeframesupdate_target_timeframe_config","title":"target_timeframes.update_target_timeframe_config","text":"<p>For updating a given target timeframe's config. This allows you to change target timeframes sensors dynamically based on other outside criteria (e.g. you need to adjust the target hours to top up home batteries).</p> Attribute Optional Description <code>target.entity_id</code> <code>no</code> The name of the target sensor whose configuration is to be updated. <code>data.target_hours</code> <code>yes</code> The optional number of hours the target timeframe sensor should come on during a 24 hour period. Must be divisible by 0.5. <code>data.target_start_time</code> <code>yes</code> The optional time the evaluation period should start. Must be in the format of <code>HH:MM</code>. <code>data.target_end_time</code> <code>yes</code> The optional time the evaluation period should end. Must be in the format of <code>HH:MM</code>. <code>data.target_offset</code> <code>yes</code> The optional offset to apply to the target timeframe when it starts. Must be in the format <code>(+/-)HH:MM:SS</code>. <code>data.target_minimum_value</code> <code>yes</code> The optional minimum timeframe the selected timeframes should not go below. <code>data.target_maximum_value</code> <code>yes</code> The optional maximum timeframe the selected timeframes should not go above. <code>data.target_weighting</code> <code>yes</code> The optional weighting that should be applied to the selected timeframes. <code>data.persist_changes</code> <code>yes</code> Determines if the changes should be persisted to the original configuration or should be temporary and reset upon integration reload. If not supplied, then the changes are temporary"},{"location":"services/#automation-example","title":"Automation Example","text":"<p>This can be used via automations in the following way. Assuming we have the following inputs.</p> <pre><code>input_number:\n  target_timeframes_target_hours:\n    name: Target Timeframes Target Hours\n    min: 0\n    max: 24\n\ninput_text:\n  # From/to would ideally use input_datetime, but we need the time in a different format\n  target_timeframes_target_from:\n    name: Target Timeframes Target From\n    initial: \"00:00\"\n  target_timeframes_target_to:\n    name: Target Timeframes Target To\n    initial: \"00:00\"\n  target_timeframes_target_offset:\n    name: Target Timeframes Target Offset\n    initial: \"-00:00:00\"\n</code></pre> <p>Then an automation might look like the following</p> <pre><code>mode: single\nalias: Update target timeframe config\ntriggers:\n  - trigger: state\n    entity_id:\n      - input_number.target_timeframes_target_hours\n      - input_text.target_timeframes_target_from\n      - input_text.target_timeframes_target_to\n      - input_text.target_timeframes_target_offset\nconditions: []\nactions:\n  - action: target_timeframes.update_target_timeframe_config\n    data:\n      target_hours: &gt;\n        {{ states('input_number.target_timeframes_target_hours') }}\n      target_start_time: &gt;\n        {{ states('input_text.target_timeframes_target_from') }}\n      target_end_time: &gt;\n        {{ states('input_text.target_timeframes_target_to') }}\n      target_offset: &gt;\n        {{ states('input_text.target_timeframes_target_offset') }}\n    target:\n      entity_id: binary_sensor.target_timeframes_target_example\n</code></pre>"},{"location":"services/#rolling-target-timeframes","title":"Rolling Target Timeframes","text":"<p>The following services are available if you have set up at least one rolling target timeframe.</p>"},{"location":"services/#target_timeframesupdate_rolling_target_timeframe_config","title":"target_timeframes.update_rolling_target_timeframe_config","text":"<p>For updating a given rolling target timeframe's config. This allows you to change rolling target timeframes sensors dynamically based on other outside criteria (e.g. you need to adjust the target hours to top up home batteries).</p> Attribute Optional Description <code>target.entity_id</code> <code>no</code> The name of the target sensor whose configuration is to be updated. <code>data.target_hours</code> <code>yes</code> The optional number of hours the target timeframe sensor should come on during a 24 hour period. Must be divisible by 0.5. <code>data.target_look_ahead_hours</code> <code>yes</code> The optional number of hours worth of timeframes the sensor should look at for the evaluation period. <code>data.target_offset</code> <code>yes</code> The optional offset to apply to the target timeframe when it starts. Must be in the format <code>(+/-)HH:MM:SS</code>. <code>data.target_minimum_value</code> <code>yes</code> The optional minimum timeframe the selected timeframes should not go below. <code>data.target_maximum_value</code> <code>yes</code> The optional maximum timeframe the selected timeframes should not go above. <code>data.target_weighting</code> <code>yes</code> The optional weighting that should be applied to the selected timeframes. <code>data.persist_changes</code> <code>yes</code> Determines if the changes should be persisted to the original configuration or should be temporary and reset upon integration reload. If not supplied, then the changes are temporary"},{"location":"services/#automation-example_1","title":"Automation Example","text":"<p>This can be used via automations in the following way. Assuming we have the following inputs.</p> <pre><code>input_number:\n  target_timeframes_rolling_target_hours:\n    name: Target Timeframes Rolling Target Hours\n    min: 0\n    max: 24\n  target_timeframes_rolling_target_look_ahead_hours:\n    name: Target Timeframes Rolling Target Look Ahead Hours\n    min: 0\n    max: 24\n\ninput_text:\n  target_timeframes_target_offset:\n    name: Target Timeframes Target Offset\n    initial: \"-00:00:00\"\n</code></pre> <p>Then an automation might look like the following</p> <pre><code>mode: single\nalias: Update target timeframe config\ntriggers:\n  - trigger: state\n    entity_id:\n      - input_number.target_timeframes_rolling_target_hours\n      - input_number.target_timeframes_rolling_target_look_ahead_hours\n      - input_text.target_timeframes_target_offset\nconditions: []\nactions:\n  - action: target_timeframes.update_target_timeframe_config\n    data:\n      target_hours: &gt;\n        {{ states('input_number.target_timeframes_target_hours') }}\n      target_look_ahead_hours: &gt;\n        {{ states('input_number.target_timeframes_rolling_target_look_ahead_hours') }}\n      target_offset: &gt;\n        {{ states('input_text.target_timeframes_target_offset') }}\n    target:\n      entity_id: binary_sensor.target_timeframes_rolling_target_example\n</code></pre>"},{"location":"sponsorship/","title":"Sponsorship","text":"<p>If you are enjoying the integration, why not make a one off or monthly GitHub sponsorship.</p>"},{"location":"repairs/invalid_target_timeframe/","title":"Repairs - Invalid Target Timeframe","text":"<p>If you receive this error, it means that one or more of your target timeframe sensors have gone into an invalid state. This can happen if more validation has been added, which your target timeframe sensor(s) are in violation of.</p> <p>To solve this</p> <ol> <li>Go to your integration</li> <li>Click configure against the target timeframe sensor that is in violation</li> <li>Update the config and save your changes</li> </ol> <p>If you are still having issues, feel free to raise a discussion.</p>"},{"location":"setup/data_source/","title":"Data source","text":"<p>Data sources help group target timeframe sensors together to be fed from a central data source. These data sources take a specific shape, but can represent anything. To start configuring target timeframe sensors, you'll need to create an initial data source. This can be done via the integration UI.</p> <p>Once the data source has been created, you'll have the following entities created. You'll then need to use the available service to configure the underlying data. There are also a collection of blueprints available for loading popular data sources.</p>"},{"location":"setup/data_source/#entities","title":"Entities","text":""},{"location":"setup/data_source/#data-source-last-updated","title":"Data Source Last Updated","text":"<p><code>sensor.target_timeframes_{{DATA_SOURCE_ID}}_data_source_last_updated</code></p> <p>This entity represents when the data source data was last updated via the associated service.</p> Attribute Type Description <code>data_source_id</code> <code>string</code> The id of the underlying data source. <code>data</code> <code>list</code> The current collection of data associated with the data source. <p>For each item within <code>data</code>, you get the following attributes</p> Attribute Type Description <code>start</code> <code>datetime</code> The start datetime of the period the value is applicable for. <code>end</code> <code>datetime</code> The end datetime of the period the value is applicable for. <code>value</code> <code>float</code> The value associated with the time period. This is what drives the target timeframe sensors. <code>metadata</code> <code>object</code> The optional metadata associated with the timeframe. This can be used to show how the value was calculated. This is up to the datasource to determine the shape and will vary."},{"location":"setup/rolling_target_timeframe/","title":"Rolling Target Timeframe Sensor(s)","text":"<p>After you've configured your data source, you'll be able to configure rolling target timeframe sensors. These are configured as sub configuration options associated with your data source. Select <code>Rolling Target Timeframe</code> from the sub menu.</p> <p>These sensors calculate the lowest continuous or intermittent values within the next available <code>x</code> hours, where <code>x</code> is configurable via the sensor, and turn on when these periods are active. If you are targeting an export meter, then the sensors will calculate the highest continuous or intermittent values within the next available <code>x</code> hours and turn on when these periods are active. If you are wanting to evaluate on a fixed basis (e.g. every 24 hours), you might be interested in the standard target timeframe sensors</p> <p>These sensors can then be used in automations to turn on/off devices that save you (and the planet) energy and money. You can go through this flow as many times as you need rolling target timeframe sensors.</p> <p>Each sensor will be in the form <code>binary_sensor.target_timeframes_{{DATA_SOURCE_ID}}_{{TARGET_TIMEFRAME_NAME}}</code>.</p>"},{"location":"setup/rolling_target_timeframe/#setup","title":"Setup","text":""},{"location":"setup/rolling_target_timeframe/#hours","title":"Hours","text":"<p>The hours that you require for the sensor to find. This should be in decimal format and represent 30 minute increments. For example 30 minutes would be <code>0.5</code>, 1 hour would be <code>1</code> or <code>1.0</code>, 1 hour and 30 minutes would be <code>1.5</code>, etc.</p>"},{"location":"setup/rolling_target_timeframe/#hours-mode","title":"Hours Mode","text":"<p>There are three different modes that the target timeframe sensor can be set to, which determines how the specified hours should be interpreted</p>"},{"location":"setup/rolling_target_timeframe/#exact-default","title":"Exact (default)","text":"<p>The target timeframe sensor will try to find the best times for the specified hours. If less than the target hours are discovered, the sensor will not come on at all. If there are more hours than required that meet the specified requirements (e.g. below a certain value), then it will come on for the lowest available times up to the specified hours.</p> <p>For instance if the lowest period is between <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code> and your target timeframe is for 1 hour, then it will come on between  <code>2023-01-01T00:30</code> and <code>2023-01-01T01:30</code>. If the available times are between <code>2023-01-01T00:30</code> and <code>2023-01-01T01:00</code>, then the sensor will not come on at all.</p>"},{"location":"setup/rolling_target_timeframe/#minimum","title":"Minimum","text":"<p>The target timeframe sensor will try to find the best times for the specified hours. If less than the target hours are discovered, the sensor will not come on at all. If there are more hours than required that meet the specified requirements (e.g. below a certain value), then it will come on for all discovered times.</p> <p>For instance if the lowest period is between <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code> and your target timeframe is for 1 hour, then it will come on between  <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code>. If the available times are between <code>2023-01-01T00:30</code> and <code>2023-01-01T01:00</code>, then the sensor will not come on at all.</p>"},{"location":"setup/rolling_target_timeframe/#maximum","title":"Maximum","text":"<p>The target timeframe sensor will try to find the best times for the specified hours. If less than the target hours are discovered, the sensor will come on for all times that are discovered. If there are more hours than required that meet the specified requirements (e.g. below a certain value), then it will come on for the lowest available times up to the specified hours.</p> <p>For instance if the lowest period is between <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code> and your target timeframe is for 1 hour, then it will come on between  <code>2023-01-01T00:30</code> and <code>2023-01-01T01:30</code>. If the available times are between <code>2023-01-01T00:30</code> and <code>2023-01-01T01:00</code>, then the sensor will come on between  <code>2023-01-01T00:30</code> and <code>2023-01-01T01:00</code>.</p>"},{"location":"setup/rolling_target_timeframe/#look-ahead-hours","title":"Look Ahead Hours","text":"<p>This is the number of hours to look ahead for the best time periods. This will include the current time period. For instance, if it's <code>2023-01-01T00:15</code> and you have your look ahead hours set to <code>8</code>, then it will look for the best times between <code>2023-01-01T00:00</code> and <code>2023-01-01T08:00</code>.</p>"},{"location":"setup/rolling_target_timeframe/#evaluation-mode","title":"Evaluation mode","text":"<p>Because the time frame that is being evaluated could change at different frequencies depending on the source, you might want to set how/when the target times are evaluated in order to make the selected times more or less dynamic.</p>"},{"location":"setup/rolling_target_timeframe/#all-existing-target-timeframes-are-in-the-past","title":"All existing target timeframes are in the past","text":"<p>This is the default way of evaluating target times. This will only evaluate new target times if no target times have been calculated or all existing target times are in the past.</p>"},{"location":"setup/rolling_target_timeframe/#existing-target-timeframes-havent-started-or-finished","title":"Existing target timeframes haven't started or finished","text":"<p>This will only evaluate target times if no target times have been calculated or all existing target times are either in the future or all existing target times are in the past. </p> <p>For example, lets say we have a continuous rolling target which looks ahead for <code>8</code> hours and has existing target times from <code>2023-01-02T01:00</code> to <code>2023-01-02T02:00</code>. </p> <ul> <li>If the current time is <code>2023-01-02T00:59</code>, then the target times will be re-evaluated and might change if the new rolling target period (i.e. <code>2023-01-02T00:30</code> to <code>2023-01-02T08:30</code>) has better times than the existing target times.</li> <li>If the current time is <code>2023-01-02T01:00</code>, the the target times will not be re-evaluated because we've entered our current target times, even if the new rolling target period has cheaper times. </li> <li>If the current time is <code>2023-01-02T02:01</code>, the the target times will be re-evaluated because our existing target times are in the past and will find the best times in the new rolling target period (i.e. <code>2023-01-02T02:00</code> to <code>2023-01-02T10:00</code>). </li> </ul>"},{"location":"setup/rolling_target_timeframe/#always","title":"Always","text":"<p>This will always evaluate the best target times for the rolling target period, even if the sensor is in the middle of an existing target time period.</p> <p>For example, lets say we have a continuous rolling target which looks ahead for <code>8</code> hours and has existing target times from <code>2023-01-02T01:00</code> to <code>2023-01-02T02:00</code>. </p> <ul> <li>If the current time is <code>2023-01-02T00:59</code>, then the target times will be re-evaluated and might change if the new rolling target period (i.e. <code>2023-01-02T00:30</code> to <code>2023-01-02T08:30</code>) has better times than the existing target times.</li> <li>If the current time is <code>2023-01-02T01:31</code>, then the target times will be re-evaluated and might change if the new rolling target period (i.e. <code>2023-01-02T01:30</code> to <code>2023-01-02T09:30</code>) has better times than the existing target times.</li> <li>If the current time is <code>2023-01-02T02:01</code>, the the target times will be re-evaluated because our existing target times are in the past and will find the best times in the new rolling target period (i.e. <code>2023-01-02T02:00</code> to <code>2023-01-02T10:00</code>). </li> </ul> <p>Warning</p> <p>This setting means that you could end up with the sensor not turning on for the fully requested hours as the target times might be moved ahead half way through the picked times. It also could mean that the sensor doesn't come on at all during the requested look ahead hours (e.g. 8) because the lowest period kept moving back. </p>"},{"location":"setup/rolling_target_timeframe/#offset","title":"Offset","text":"<p>You may want your target timeframe sensors to turn on a period of time before the optimum discovered period. For example, you may be turning on a robot vacuum cleaner for a 30 minute clean and want it to charge during the optimum period. For this, you'd use the <code>offset</code> field and set it to <code>-00:30:00</code>, which can be both positive and negative and go up to a maximum of 24 hours. This will shift when the sensor turns on relative to the optimum period. For example, if the optimum period is between <code>2023-01-18T10:00</code> and <code>2023-01-18T11:00</code> with an offset of <code>-00:30:00</code>, the sensor will turn on between <code>2023-01-18T09:30</code> and <code>2023-01-18T10:30</code>.</p>"},{"location":"setup/rolling_target_timeframe/#latest-period","title":"Latest Period","text":"<p>Depending on how you're going to use the sensor, you might want the best period at the latest possible time. For example, you might be using the sensor to turn on an immersion heater which you'll want to come on at the end of the lowest found period. </p> <p>For instance if you turn this on and the lowest period is between <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code> and your target timeframe is for 1 hour, then it will come on between <code>2023-01-01T04:00</code> and <code>2023-01-01T05:00</code> instead of <code>2023-01-01T00:30</code> and <code>2023-01-01T01:30</code>.</p> <p>This feature is toggled on by the <code>Find last applicable values</code> checkbox.</p>"},{"location":"setup/rolling_target_timeframe/#find-highest-value","title":"Find highest value","text":"<p>If this is checked, then the highest values will be discovered, instead of the normal behaviour of the lowest values.</p>"},{"location":"setup/rolling_target_timeframe/#minimummaximum-values","title":"Minimum/Maximum Values","text":"<p>There may be times that you want the target timeframe sensors to not take into account values that are above or below a certain value (e.g. you don't want the sensor to turn on when values go crazy or where it would be more beneficial to export).</p> <p>Info</p> <p>If hours mode is set to minimum, then a minimum and/or maximum rate must be specified in order for the target timeframe sensor to know what the cut off is for discovered times.</p>"},{"location":"setup/rolling_target_timeframe/#weighting","title":"Weighting","text":"<p>Info</p> <p>This is only available for continuous target timeframe sensors in exact hours mode.</p> <p>There may be times when the device you're wanting the target timeframe sensor to turn on doesn't have a consistent power draw. You can specify a weighting which can be applied to each discovered 30 minute slot. This can be specified in a few different ways. Take the following example weighting for a required 2 hours.</p> <ul> <li><code>1,1,2,1</code> - This applies a weighting of 1 to the first, second and forth slot and a weighting of 2 to the third slot. This will try and make the lowest slot fall on the third slot, as long as the surrounding slots are cheaper than other continuous slots.</li> <li><code>*,2,1</code> - This applies a weighting of 1 to the first, second and forth slot and a weighting of 2 to the third slot. The <code>*</code> can be used as a placeholder for the standard weighting of 1 for all slots before the ones specified.</li> <li><code>1,1,2,*</code> - This applies a weighting of 1 to the first, second and forth slot and a weighting of 2 to the third slot. The <code>*</code> can be used as a placeholder for the standard weighting of 1 for all slots after the ones specified.</li> <li><code>2,*,2</code> - This applies a weighting of 2 to the first and forth slot and a weighting of 1 to all slots in between. The <code>*</code> can be used as a placeholder for the standard weighting of 1 for all slots in between the specified slots.</li> </ul> <p>Each slot weighting must be a whole number or decimal number and be positive.</p> <p>You can also use weightings to ignore slots. This can be done by assigning a value of 0 for the desired slot.</p>"},{"location":"setup/rolling_target_timeframe/#attributes","title":"Attributes","text":"<p>The following attributes are available on each sensor</p> Attribute Type Description <code>name</code> <code>string</code> The name of the sensor. <code>hours</code> <code>string</code> The total hours are being discovered. <code>type</code> <code>string</code> The type/mode for the target timeframe sensor. This will be either <code>continuous</code> or <code>intermittent</code>. <code>look_ahead_hours</code> <code>float</code> The number of hours the sensor should look ahead for the best time period <code>target_times_evaluation_mode</code> <code>string</code> The mode that determines when/how target times are picked <code>last_values</code> <code>boolean</code> Determines if <code>Find last applicable values</code> is turned off for the sensor. <code>offset</code> <code>string</code> The offset configured for the sensor. <code>values_incomplete</code> <code>boolean</code> True if rate information is incomplete and therefore target times cannot be calculated; False otherwise. <code>target_times</code> <code>array</code> The discovered times and values the sensor will come on for. <code>overall_average_value</code> <code>float</code> The average value of all discovered times during the current 24 hour period. <code>overall_min_value</code> <code>float</code> The minimum value of all discovered times during the current 24 hour period. <code>overall_max_value</code> <code>float</code> The maximum value of all discovered times during the current 24 hour period. <code>current_duration_in_hours</code> <code>float</code> The duration the sensor will be on for, for the current continuous discovered period. For <code>continuous</code> sensors, this will be the entire period. For <code>intermittent</code> sensors, this could be the entire period or a portion of it, depending on the discovered times. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>current_average_value</code> <code>float</code> The average value for the current continuous discovered period. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>current_min_value</code> <code>float</code> The min value for the current continuous discovered period. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>current_max_value</code> <code>float</code> The max value for the current continuous discovered period. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>next_time</code> <code>datetime</code> The next date/time the sensor will come on. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_duration_in_hours</code> <code>float</code> The duration the sensor will be on for, for the next continuous discovered period. For <code>continuous</code> sensors, this will be the entire period. For <code>intermittent</code> sensors, this could be the entire period or a portion of it, depending on the discovered times. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_average_value</code> <code>float</code> The average value for the next continuous discovered period. For <code>continuous</code> sensors, this will be the entire period. For <code>intermittent</code> sensors, this could be the entire period or a portion of it, depending on the discovered times. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_min_value</code> <code>float</code> The average value for the next continuous discovered period. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_max_value</code> <code>float</code> The average value for the next continuous discovered period. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>target_times_last_evaluated</code> datetime The datetime the target times collection was last evaluated. This will occur if all previous target times are in the past and all values are available for the requested future time period. For example, if you are targeting 16:00 (day 1) to 16:00 (day 2), and you only have values up to 23:00 (day 1), then the target timeframes won't be calculated."},{"location":"setup/rolling_target_timeframe/#services","title":"Services","text":"<p>There are services available associated with target timeframe sensors. Please review them in the services doc.</p>"},{"location":"setup/target_timeframe/","title":"Target Timeframe Sensor(s)","text":"<p>After you've configured your data source, you'll be able to configure rolling target timeframe sensors. These are configured as sub configuration options associated with your data source. Select <code>Target timeframe</code> from the sub menu.</p> <p>These sensors calculate the lowest continuous or intermittent values within a 24 hour period and turn on when these periods are active. If you are targeting an export meter, then the sensors will calculate the highest continuous or intermittent values within a 24 hour period and turn on when these periods are active. If you are wanting to evaluate on a rolling basis, you might be interested in the rolling target value sensors</p> <p>These sensors can then be used in automations to turn on/off devices that save you (and the planet) energy and money. You can go through this flow as many times as you need target value sensors.</p> <p>Each sensor will be in the form <code>binary_sensor.target_timeframes_{{DATA_SOURCE_ID}}_{{TARGET_TIMEFRAME_NAME}}</code>.</p>"},{"location":"setup/target_timeframe/#setup","title":"Setup","text":""},{"location":"setup/target_timeframe/#target-timeframe","title":"Target Timeframe","text":"<p>If you're wanting your devices to come on during a certain timeframe, for example while you're at work, you can set the minimum and/or maximum times for your target value sensor. These are specified in 24 hour clock format and will attempt to find the optimum discovered period during these times.</p> <p>The <code>from/start</code> time can be set in the field <code>The minimum time to start the device</code> and the <code>to/end</code> time can be set in the field <code>The maximum time to stop the device</code>.</p> <p>If not specified, these default from <code>00:00:00</code> to <code>00:00:00</code> the following day.</p> <p>If for example you want to look at prices overnight you could set the minimum time to something like <code>20:00</code> and your maximum time to something like <code>05:00</code>. If the minimum time is \"after\" the maximum time, then it will treat the maximum time as the time for the following day.</p> <p>Info</p> <p>The target value will not be evaluated until all values are available for the specified timeframe. Therefore if we're looking between <code>00:00</code> and <code>00:00</code>, full value information must exist between this time. Whereas if times are between <code>10:00</code> and <code>16:00</code>, then value information is only needed between these times before it can be calculated.</p>"},{"location":"setup/target_timeframe/#hours","title":"Hours","text":"<p>The hours that you require for the sensor to find. This should be in decimal format and represent 30 minute increments. For example 30 minutes would be <code>0.5</code>, 1 hour would be <code>1</code> or <code>1.0</code>, 1 hour and 30 minutes would be <code>1.5</code>, etc.</p>"},{"location":"setup/target_timeframe/#hours-mode","title":"Hours Mode","text":"<p>There are three different modes that the target value sensor can be set to, which determines how the specified hours should be interpreted</p>"},{"location":"setup/target_timeframe/#exact-default","title":"Exact (default)","text":"<p>The target value sensor will try to find the best times for the specified hours. If less than the target hours are discovered, the sensor will not come on at all. If there are more hours than required that meet the specified requirements (e.g. below a certain value), then it will come on for the lowest available times up to the specified hours.</p> <p>For instance if the lowest period is between <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code> and your target value is for 1 hour, then it will come on between  <code>2023-01-01T00:30</code> and <code>2023-01-01T01:30</code>. If the available times are between <code>2023-01-01T00:30</code> and <code>2023-01-01T01:00</code>, then the sensor will not come on at all.</p>"},{"location":"setup/target_timeframe/#minimum","title":"Minimum","text":"<p>The target value sensor will try to find the best times for the specified hours. If less than the target hours are discovered, the sensor will not come on at all. If there are more hours than required that meet the specified requirements (e.g. below a certain value), then it will come on for all discovered times.</p> <p>For instance if the lowest period is between <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code> and your target value is for 1 hour, then it will come on between  <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code>. If the available times are between <code>2023-01-01T00:30</code> and <code>2023-01-01T01:00</code>, then the sensor will not come on at all.</p>"},{"location":"setup/target_timeframe/#maximum","title":"Maximum","text":"<p>The target value sensor will try to find the best times for the specified hours. If less than the target hours are discovered, the sensor will come on for all times that are discovered. If there are more hours than required that meet the specified requirements (e.g. below a certain value), then it will come on for the lowest available times up to the specified hours.</p> <p>For instance if the lowest period is between <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code> and your target value is for 1 hour, then it will come on between  <code>2023-01-01T00:30</code> and <code>2023-01-01T01:30</code>. If the available times are between <code>2023-01-01T00:30</code> and <code>2023-01-01T01:00</code>, then the sensor will come on between  <code>2023-01-01T00:30</code> and <code>2023-01-01T01:00</code>.</p>"},{"location":"setup/target_timeframe/#evaluation-mode","title":"Evaluation mode","text":"<p>Because the time frame that is being evaluated could change at different frequencies depending on the source, you might want to set how/when the target times are evaluated in order to make the selected times more or less dynamic.</p>"},{"location":"setup/target_timeframe/#all-existing-target-values-are-in-the-past","title":"All existing target values are in the past","text":"<p>This is the default way of evaluating target times. This will only evaluate new target times if no target times have been calculated or all existing target times are in the past.</p>"},{"location":"setup/target_timeframe/#existing-target-values-havent-started-or-finished","title":"Existing target values haven't started or finished","text":"<p>This will only evaluate target times if no target times have been calculated or all existing target times are either in the future or all existing target times are in the past. </p> <p>For example, lets say we have a continuous target which looks between <code>00:00</code> and <code>08:00</code> has existing target times from <code>2023-01-02T01:00</code> to <code>2023-01-02T02:00</code>. </p> <ul> <li>If the current time is <code>2023-01-02T00:59</code>, then the target times will be re-evaluated and might change if the target period (i.e. <code>2023-01-02T00:30</code> to <code>2023-01-02T08:30</code>) has better values than the existing target times (e.g. the external weightings have changed).</li> <li>If the current time is <code>2023-01-02T01:00</code>, the the target times will not be re-evaluated because we've entered our current target times, even if the evaluation period has cheaper times. </li> <li>If the current time is <code>2023-01-02T02:01</code>, the the target times will be re-evaluated because our existing target times are in the past and will find the best times in the new rolling target period (i.e. <code>2023-01-02T02:00</code> to <code>2023-01-02T10:00</code>). </li> </ul>"},{"location":"setup/target_timeframe/#offset","title":"Offset","text":"<p>You may want your target value sensors to turn on a period of time before the optimum discovered period. For example, you may be turning on a robot vacuum cleaner for a 30 minute clean and want it to charge during the optimum period. For this, you'd use the <code>offset</code> field and set it to <code>-00:30:00</code>, which can be both positive and negative and go up to a maximum of 24 hours. This will shift when the sensor turns on relative to the optimum period. For example, if the optimum period is between <code>2023-01-18T10:00</code> and <code>2023-01-18T11:00</code> with an offset of <code>-00:30:00</code>, the sensor will turn on between <code>2023-01-18T09:30</code> and <code>2023-01-18T10:30</code>.</p>"},{"location":"setup/target_timeframe/#re-evaluate-within-time-frame","title":"Re-evaluate within time frame","text":"<p>Depending on how you're going to use the sensor, you might want the best period to be found throughout the day so it's always available. For example, you might be using the sensor to turn on a washing machine which you might want to come on at the best time regardless of when you use the washing machine. You can activate this behaviour by setting the <code>Re-evaluate multiple times a day</code> checkbox.</p> <p>Warning</p> <p>Using this can result in the sensor coming on more than the target hours, and therefore should be used in conjunction with other sensors. Depending on how long your target timeframe is, upon each re-evaluation the picked times will get steadily worse.</p> <p>However, you might also only want the target time to occur once during each timeframe so once the best time for that day has passed it won't turn on again until the next timeframe. For example, you might be using the sensor to turn on something that isn't time critical and could wait till the next timeframe like a charger. This is the default behaviour and is done by not setting the <code>Re-evaluate multiple times a day</code> checkbox.</p> <p>Info</p> <p>The next set of target times will not be calculated until all target times are in the past. This will have an effect on the <code>next</code> set of attributes on the sensor.</p>"},{"location":"setup/target_timeframe/#latest-period","title":"Latest Period","text":"<p>Depending on how you're going to use the sensor, you might want the best period at the latest possible time. For example, you might be using the sensor to turn on an immersion heater which you'll want to come on at the end of the lowest found period. </p> <p>For instance if you turn this on and the lowest period is between <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code> and your target value is for 1 hour, then it will come on between <code>2023-01-01T04:00</code> and <code>2023-01-01T05:00</code> instead of <code>2023-01-01T00:30</code> and <code>2023-01-01T01:30</code>.</p> <p>This feature is toggled on by the <code>Find last applicable values</code> checkbox.</p>"},{"location":"setup/target_timeframe/#find-highest-value","title":"Find highest value","text":"<p>If this is checked, then the highest values will be discovered, instead of the normal behaviour of the lowest values.</p>"},{"location":"setup/target_timeframe/#minimummaximum-values","title":"Minimum/Maximum Values","text":"<p>There may be times that you want the target timeframe sensors to not take into account values that are above or below a certain value (e.g. you don't want the sensor to turn on when values go crazy or where it would be more beneficial to export).</p> <p>Info</p> <p>If hours mode is set to minimum, then a minimum and/or maximum value must be specified in order for the target timeframe sensor to know what the cut off is for discovered times.</p>"},{"location":"setup/target_timeframe/#weighting","title":"Weighting","text":"<p>Info</p> <p>This is only available for continuous target value sensors in exact hours mode.</p> <p>There may be times when the device you're wanting the target value sensor to turn on doesn't have a consistent power draw. You can specify a weighting which can be applied to each discovered 30 minute slot. This can be specified in a few different ways. Take the following example weighting for a required 2 hours.</p> <ul> <li><code>1,1,2,1</code> - This applies a weighting of 1 to the first, second and forth slot and a weighting of 2 to the third slot. This will try and make the lowest slot fall on the third slot, as long as the surrounding slots are cheaper than other continuous slots.</li> <li><code>*,2,1</code> - This applies a weighting of 1 to the first, second and forth slot and a weighting of 2 to the third slot. The <code>*</code> can be used as a placeholder for the standard weighting of 1 for all slots before the ones specified.</li> <li><code>1,1,2,*</code> - This applies a weighting of 1 to the first, second and forth slot and a weighting of 2 to the third slot. The <code>*</code> can be used as a placeholder for the standard weighting of 1 for all slots after the ones specified.</li> <li><code>2,*,2</code> - This applies a weighting of 2 to the first and forth slot and a weighting of 1 to all slots in between. The <code>*</code> can be used as a placeholder for the standard weighting of 1 for all slots in between the specified slots.</li> </ul> <p>Each slot weighting must be a whole number or decimal number and be positive.</p> <p>You can also use weightings to ignore slots. This can be done by assigning a value of 0 for the desired slot.</p>"},{"location":"setup/target_timeframe/#attributes","title":"Attributes","text":"<p>The following attributes are available on each sensor</p> Attribute Type Description <code>name</code> <code>string</code> The name of the sensor. <code>hours</code> <code>string</code> The total hours are being discovered. <code>type</code> <code>string</code> The type/mode for the target value sensor. This will be either <code>continuous</code> or <code>intermittent</code>. <code>mpan</code> <code>string</code> The <code>mpan</code> of the meter being used to determine the values. <code>target_times_evaluation_mode</code> <code>string</code> The mode that determines when/how target times are picked <code>rolling_target</code> <code>boolean</code> Determines if <code>Re-evaluate multiple times a day</code> is turned on for the sensor. <code>last_values</code> <code>boolean</code> Determines if <code>Find last applicable values</code> is turned off for the sensor. <code>offset</code> <code>string</code> The offset configured for the sensor. <code>start_time</code> <code>string</code> The start time configured for the sensor. <code>end_time</code> <code>string</code> The end time configured for the sensor. <code>values_incomplete</code> <code>boolean</code> True if value information is incomplete and therefore target times cannot be calculated; False otherwise. <code>target_times</code> <code>array</code> The discovered times and values the sensor will come on for. <code>overall_average_value</code> <code>float</code> The average value of all discovered times during the current 24 hour period. <code>overall_min_value</code> <code>float</code> The minimum value of all discovered times during the current 24 hour period. <code>overall_max_value</code> <code>float</code> The maximum value of all discovered times during the current 24 hour period. <code>current_duration_in_hours</code> <code>float</code> The duration the sensor will be on for, for the current continuous discovered period. For <code>continuous</code> sensors, this will be the entire period. For <code>intermittent</code> sensors, this could be the entire period or a portion of it, depending on the discovered times. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>current_average_value</code> <code>float</code> The average value for the current continuous discovered period. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>current_min_value</code> <code>float</code> The min value for the current continuous discovered period. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>current_max_value</code> <code>float</code> The max value for the current continuous discovered period. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>next_time</code> <code>datetime</code> The next date/time the sensor will come on. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_duration_in_hours</code> <code>float</code> The duration the sensor will be on for, for the next continuous discovered period. For <code>continuous</code> sensors, this will be the entire period. For <code>intermittent</code> sensors, this could be the entire period or a portion of it, depending on the discovered times. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_average_value</code> <code>float</code> The average value for the next continuous discovered period. For <code>continuous</code> sensors, this will be the entire period. For <code>intermittent</code> sensors, this could be the entire period or a portion of it, depending on the discovered times. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_min_value</code> <code>float</code> The average value for the next continuous discovered period. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_max_value</code> <code>float</code> The average value for the next continuous discovered period. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>target_times_last_evaluated</code> datetime The datetime the target times collection was last evaluated. This will occur if all previous target times are in the past and all values are available for the requested future time period. For example, if you are targeting 16:00 (day 1) to 16:00 (day 2), and you only have values up to 23:00 (day 1), then the target values won't be calculated."},{"location":"setup/target_timeframe/#services","title":"Services","text":"<p>There are services available associated with target value sensors. Please review them in the services doc.</p>"},{"location":"setup/target_timeframe/#examples","title":"Examples","text":"<p>Let's look at a few examples. Let's say we have the the following (unrealistic) set of values:</p> start end value <code>2023-01-01T00:00</code> <code>2023-01-01T00:30</code> 6 <code>2023-01-01T00:30</code> <code>2023-01-01T05:00</code> 12 <code>2023-01-01T05:00</code> <code>2023-01-01T05:30</code> 7 <code>2023-01-01T05:30</code> <code>2023-01-01T18:00</code> 20 <code>2023-01-01T18:00</code> <code>2023-01-01T23:30</code> 34 <code>2023-01-01T23:30</code> <code>2023-01-02T00:30</code> 5 <code>2023-01-02T00:30</code> <code>2023-01-02T05:00</code> 12 <code>2023-01-02T05:00</code> <code>2023-01-02T05:30</code> 7 <code>2023-01-02T05:30</code> <code>2023-01-02T18:00</code> 20 <code>2023-01-02T18:00</code> <code>2023-01-02T23:00</code> 34 <code>2023-01-02T23:30</code> <code>2023-01-03T00:00</code> 6"},{"location":"setup/target_timeframe/#continuous","title":"Continuous","text":"<p>If we look at a continuous sensor that we want on for 1 hour.</p> <p>If we set no from/to times, then our 24 hour period being looked at ranges from <code>00:00:00</code> to <code>23:59:59</code>.</p> <p>The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T00:00</code> <code>2023-01-01T00:00</code> - <code>2023-01-01T01:00</code> <code>false</code> While 5 is our lowest value within the current 24 hour period, it doesn't cover our whole 1 hour and is next to a high 34 value. A value of 6 is the next available value with a low following value. <code>2023-01-01T01:00</code> <code>2023-01-02T00:00</code> - <code>2023-01-02T01:00</code> <code>false</code> Our lowest period is in the past, so we have to wait until our target period has passed to look at the next evaluation period. <code>2023-01-01T01:00</code> <code>2023-01-01T04:30</code> - <code>2023-01-01T05:30</code> <code>true</code> The value of 6 is in the past, so 7 is our next lowest value. 12 is smaller value than 20 so we start in the value period before to fill our desired hour. <code>2023-01-01T23:30</code> None <code>true</code> There is no longer enough time available in the current 24 hour period, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set our from/to times for <code>05:00</code> to <code>19:00</code>, we then limit the period that we look at. The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T00:00</code> <code>2023-01-01T05:00</code> - <code>2023-01-01T06:00</code> <code>false</code> The value of 12 is no longer available as it's outside of our <code>from</code> time. <code>2023-01-01T06:30</code> <code>2023-01-02T05:00</code> - <code>2023-01-02T06:00</code> <code>false</code> Our lowest period is in the past, so we have to wait until our target period has passed to look at the next evaluation period. <code>2023-01-01T06:30</code> <code>2023-01-01T06:30</code> - <code>2023-01-01T07:30</code> <code>true</code> The value of 7 is in the past, so we must look for the next lowest combined value. <code>2023-01-01T18:00</code> <code>2023-01-01T18:00</code> - <code>2023-01-01T19:00</code> <code>true</code> The value of 20 is in the past, so we must look for the next lowest combined value which is 34. <code>2023-01-01T18:30</code> None <code>true</code> There is no longer enough time available within our restricted time, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set our from/to times to look over two days, from <code>20:00</code> to <code>06:00</code>, we then limit the period that we look at to overnight. The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T20:00</code> <code>2023-01-01T23:30</code> - <code>2023-01-02T01:30</code> <code>false</code> Our lowest value of 5 now falls between our overnight time period so is available. <code>2023-01-02T02:00</code> <code>2023-01-01T23:30</code> - <code>2023-01-02T01:30</code> <code>false</code> Our lowest period is in the past, so we have to wait until our target period has passed to look at the next evaluation period. <code>2023-01-02T02:00</code> <code>2023-01-02T04:30</code> - <code>2023-01-02T05:30</code> <code>true</code> The value of 5 is in the past, so we must look for the next lowest combined value, which includes our half hour value at 7. <code>2023-01-02T05:30</code> None <code>true</code> There is no longer enough time available within our restricted time, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set an offset of <code>-00:30:00</code>, then while the times might be the same, the target value sensor will turn on 30 minutes before the select value period starts. Any set time restrictions will not include the offset.</p>"},{"location":"setup/target_timeframe/#intermittent","title":"Intermittent","text":"<p>If we look at an intermittent sensor that we want on for 1 hour total (but not necessarily together).</p> <p>If we set no from/to times, then our 24 hour period being looked at ranges from <code>00:00:00</code> to <code>23:59:59</code>.</p> <p>The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T00:00</code> <code>2023-01-01T00:00</code> - <code>2023-01-01T00:30</code>, <code>2023-01-01T23:30</code> - <code>2023-01-02T00:00</code> <code>false</code> Our sensor will go on for 30 minutes at the lowest value, then 30 minutes at the next lowest value. <code>2023-01-01T01:00</code> <code>2023-01-01T00:00</code> - <code>2023-01-01T00:30</code>, <code>2023-01-01T23:30</code> - <code>2023-01-02T00:00</code> <code>false</code> Our sensor will go on for 30 minutes at the lowest value, which will be in the past, then 30 minutes at the next lowest value. <code>2023-01-01T01:00</code> <code>2023-01-01T05:00</code> - <code>2023-01-01T05:30</code>, <code>2023-01-01T23:30</code> - <code>2023-01-02T00:00</code> <code>true</code> Our sensor will go on for 30 minutes at the second lowest value, then 30 minutes at the third lowest value. <code>2023-01-01T23:30</code> None <code>true</code> There is no longer enough time available in the current 24 hour period, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set our from/to times for <code>05:00</code> to <code>19:00</code>, we then limit the period that we look at. The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T00:00</code> <code>2023-01-01T05:00</code> - <code>2023-01-01T05:30</code>, <code>2023-01-01T05:30</code> - <code>2023-01-01T06:00</code> <code>false</code> Our lowest values are outside our target range, so we need to look at the next lowest. Luckily on our scenario the two lowest values are next to each other. <code>2023-01-01T06:30</code> <code>2023-01-01T05:00</code> - <code>2023-01-01T05:30</code>, <code>2023-01-01T05:30</code> - <code>2023-01-01T06:00</code> <code>false</code> Both of our lowest values in the target range are in the past. <code>2023-01-01T06:30</code> <code>2023-01-01T06:30</code> - <code>2023-01-01T07:00</code>, <code>2023-01-01T07:00</code> - <code>2023-01-01T07:30</code> <code>true</code> Both of our lowest values in the target range are in the past, so we must look for the next lowest combined value. <code>2023-01-01T18:30</code> None <code>true</code> There is no longer enough time available within our restricted time, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set our from/to times to look over two days, from <code>20:00</code> to <code>06:00</code>, we then limit the period that we look at to overnight. The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T20:00</code> <code>2023-01-01T23:30</code> - <code>2023-01-02T00:30</code>, <code>2023-01-02T05:00</code> - <code>2023-01-02T05:30</code> <code>false</code> Our lowest value of 5 now falls between our overnight time period so is available. <code>2023-01-02T02:00</code> <code>2023-01-01T23:30</code> - <code>2023-01-02T00:30</code>, <code>2023-01-02T05:00</code> - <code>2023-01-02T05:30</code> <code>false</code> Our lowest period is in the past, but we still have a value in the future so our sensor will only come on once. <code>2023-01-02T02:00</code> <code>2023-01-02T02:00</code> - <code>2023-01-02T02:30</code>, <code>2023-01-02T05:00</code> - <code>2023-01-02T05:30</code> <code>true</code> The value of 5 is in the past, so we must look for the next lowest combined value, which includes our half hour value at 7. <code>2023-01-02T05:30</code> None <code>true</code> There is no longer enough time available within our restricted time, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set an offset of <code>-00:30:00</code>, then while the times might be the same, the target value sensor will turn on 30 minutes before the select value period starts. Any set time restrictions will not include the offset.</p>"}]}